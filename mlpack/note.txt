format supporté par data::Load(): pour être sûr ImageFormatSupported()

    csv (comma-separated values), denoted by .csv or .txt
    tsv (tab-separated values), denoted by .tsv, .csv, or .txt
    ASCII (raw ASCII, with space-separated values), denoted by .txt
    Armadillo ASCII (Armadillo's text format with a header), denoted by .txt
    PGM, denoted by .pgm
    PPM, denoted by .ppm
    Armadillo binary, denoted by .bin
    Raw binary, denoted by .bin (note: this will be loaded as one-dimensional data, which is likely not what is desired.)
    HDF5, denoted by .hdf, .hdf5, .h5, or .he5 (note: HDF5 must be enabled in the Armadillo configuration)
    ARFF, denoted by .arff (note: this is not supported by all mlpack command-line programs ; see Categorical features and command line programs)

format des Matrices:
Quand on load un csv, normalement les colonnes correspondent aux différentes dimensions du dataset et les lignes à un point mais ici les matrices chargent les csv en transposant colonne et ligne

Idée pour le modèle:
4 CNN : 2 pour la case de départ (c1, l1), 2 pour la case à atteindre (c2, l2) : [c1, l1, c2, l2]
Donc en entrée : un plateau d'échec et en sortie respectivement : la pièce à bouger, la colonne où aller et la ligne où aller.
Les pièces doivent être mise sous la forme de vecteur : OneLoneCoder(), 12 pièces donc de dimension 24,
les features doivent donc être de dimension 64*12 = 768 si on fait des couches denses seulement,
mais on va utiliser des CNN donc l'entrée est de dimension 12*8x8 = 96x8
Les sorties seront respectivement de dimension : 8, 8, 8, 8                                                                                                        _
On a donc 3 modèles à entrainer avec des données de la forme (plateau, pièce, c, l), avec plateau : X : ([0,1,0,0,0,0,0,0,0,0,0,0], ..., [0,0,0,0,0,0,0,0,1,0,0,0]) |   y : c1, l1, c2, l2
                                                                                                        |___________________________12x8__________________________| |
                                                                                                                                                                    8
                                                                                                                                                                    |
                                                                                                                                                                   _|
Peut-être faire un modèle pour les noirs et un autre pour les blancs
il va falloir coder un convertisseur : e5,e4... -> e, 7, e, 5

dataset : https://www.kaggle.com/rishidamarla/chess-games
chess notation : https://www.ichess.net/blog/chess-notation/

Fonctions à faire: pour chaque couleur
- vector<string> ExtractMovesSet(string filename) : extraits l'ensembles des coups pour toutes les parties du dataset, les coup seront écrits sans les +,x,#
- vector<int> ConvertPieceToVect()
- vector<Chess> ConvertMovesToVectChess(vector<string> moves) : cette fonction prend en entrée tous les coups d'une partie et les convertis en ensemble d'états (Chess) de la partie
- void SaveToFormatCSV(vector<Chess> partie) : sauvegarde l'ensemble des parties au format défini précédemment : plateau, pièce, colonne, ligne

Convertir un pièce en vecteur:
 - [Pion, Cavalier, Tour, Fou, Dame, Roi, Noir, Blanc] -> Je test ça, taille : 8
 - [Pion, Cavalier, Tour, Fou, Dame, Roi]
 - [PionB, CavalierB, TourB, FouB, DameB, RoiB, PionN, CavalierN, TourN, FouN, DameN, RoiN]

 Les parties sont de elo >= 2500 ce qui donne un dataset de 8346 coups, si on a besoin de plus on baisse le elo minimum : ELO_MIN dans DataCSV.h
 Je rajoute un bit de fin pour savoir quelle est la couleur de celui qui joue

 Une ligne du dataset DataGmes.csv :
 [[0,0,1,0,0,0,0,1], ...., [1,0,0,0,0,0,0,0]] + c1 l1 c2 l2 couleur (celui qui joue)
  |_______8_______|
|_____________________8*64__________________|

à faire : 
    - Pourquoi y a des -1 -> règle du en passant
    - Ajouter le coup en passant et véridier le rook, pas sur de l'avoir bien implémenter

Matrice d'entrée du CNN : un transforme un ligne du dataset en matrice 2D 64x8
                                            _
[[0,0,1,0,0,0,0,1], ...., [1,0,0,0,0,0,0,0]] |
 |_______8_______|                           |
|_____________________8*8__________________| |
                                             8
                                             |
                                             |
                                            _|
                                            
Idée pour le Split : 
Refaire un Split(X,y) pour chaque modèle : y_c1, y_l1, y_c2, y_l2

Le modèle tel que je l'ai décrit ne fonctionne pas : 40% d'accuracy sur le validation set ---> Très mauvais
Mais bonne nouvelle c'est pas moi qui suis nul, en réalité les CNN tel que je l'ai utilisé ne fonctionne pas, on ne peut pas prédire le prochain
coup jste avec des CNN. (cf Predicting Moves in Chess Using CNN by Barak Oshri)

Nouveau model : 
Créer un heuristic pour MiniMax grâce aux CNN
Le dataset change pas mais on doit utiliser un nouveau y qui va représenter l'heuristic : h = sign(qui gagne la partie)*i/nb_coup

d4 d5 c4 e6 Nc3 c6 e3 Nf6 Nf3 Nbd7 Bd3 Bb4 Qb3 Qa5 O-O Bc3 bc3 O-O Ba3 Re8 Bb4 Qa6 Rad1 Qb6 c5 Qc7 Qc2 e5 Nh4 e4 Be2 g5 Nf5 Nf8 Nd6 Re7 f4 Ng4 Qd2 a5 Ba3 f6 fg5 fg5 Rb1 Nh6 Qc2 Nf7 Bh5 Nh6 c4 dc4 Qc4 Be6 Qc2 Bc8 Ne4 Ng4 Bg4 Bg4 Nf6 Kh8 Ng4 h5 Ne5 Kg8 Qf5 Rg7 h4 gh4 Qh5 Qe7 Ng4 Rh7 Nh6 Kh8 Rb3 Qg7 Nf7 Kg8 Qe2 h3 Rb7 h2 Kh1 Re8 Nd6 Qb7 Nb7 Rb7 Kh2 Ng6 Rf6 Nf8 Rc6 Rbe7 Qc4 Rf7 Rf6 Re7 c6 Rc7 Qd5 Nh7 Rg6 Kh8 Qd8 Nf8 Bf8 Kh7 Rh6 Kg8 Bc5 Kg7 Qh8 