format supporté par data::Load(): pour être sûr ImageFormatSupported()

    csv (comma-separated values), denoted by .csv or .txt
    tsv (tab-separated values), denoted by .tsv, .csv, or .txt
    ASCII (raw ASCII, with space-separated values), denoted by .txt
    Armadillo ASCII (Armadillo's text format with a header), denoted by .txt
    PGM, denoted by .pgm
    PPM, denoted by .ppm
    Armadillo binary, denoted by .bin
    Raw binary, denoted by .bin (note: this will be loaded as one-dimensional data, which is likely not what is desired.)
    HDF5, denoted by .hdf, .hdf5, .h5, or .he5 (note: HDF5 must be enabled in the Armadillo configuration)
    ARFF, denoted by .arff (note: this is not supported by all mlpack command-line programs ; see Categorical features and command line programs)

format des Matrices:
Quand on load un csv, normalement les colonnes correspondent aux différentes dimensions du dataset et les lignes à un point mais ici les matrices chargent les csv en transposant colonne et ligne

Idée pour le modèle:
4 CNN : 2 pour la case de départ (c1, l1), 2 pour la case à atteindre (c2, l2) : [c1, l1, c2, l2]
Donc en entrée : un plateau d'échec et en sortie respectivement : la pièce à bouger, la colonne où aller et la ligne où aller.
Les pièces doivent être mise sous la forme de vecteur : OneLoneCoder(), 12 pièces donc de dimension 24,
les features doivent donc être de dimension 64*12 = 768 si on fait des couches denses seulement,
mais on va utiliser des CNN donc l'entrée est de dimension 12*8x8 = 96x8
Les sorties seront respectivement de dimension : 8, 8, 8, 8                                                                                                        _
On a donc 3 modèles à entrainer avec des données de la forme (plateau, pièce, c, l), avec plateau : X : ([0,1,0,0,0,0,0,0,0,0,0,0], ..., [0,0,0,0,0,0,0,0,1,0,0,0]) |   y : c1, l1, c2, l2
                                                                                                        |___________________________12x8__________________________| |
                                                                                                                                                                    8
                                                                                                                                                                    |
                                                                                                                                                                   _|
Peut-être faire un modèle pour les noirs et un autre pour les blancs
il va falloir coder un convertisseur : e5,e4... -> e, 7, e, 5

dataset : https://www.kaggle.com/rishidamarla/chess-games
chess notation : https://www.ichess.net/blog/chess-notation/

Fonctions à faire: pour chaque couleur
- vector<string> ExtractMovesSet(string filename) : extraits l'ensembles des coups pour toutes les parties du dataset, les coup seront écrits sans les +,x,#
- vector<int> ConvertPieceToVect()
- vector<Chess> ConvertMovesToVectChess(vector<string> moves) : cette fonction prend en entrée tous les coups d'une partie et les convertis en ensemble d'états (Chess) de la partie
- void SaveToFormatCSV(vector<Chess> partie) : sauvegarde l'ensemble des parties au format défini précédemment : plateau, pièce, colonne, ligne

Convertir un pièce en vecteur:
 - [Pion, Cavalier, Tour, Fou, Dame, Roi, Noir, Blanc] -> Je test ça, taille : 8
 - [Pion, Cavalier, Tour, Fou, Dame, Roi]
 - [PionB, CavalierB, TourB, FouB, DameB, RoiB, PionN, CavalierN, TourN, FouN, DameN, RoiN]

 Les parties sont de elo >= 2500 ce qui donne un dataset de 8346 coups, si on a besoin de plus on baisse le elo minimum : ELO_MIN dans DataCSV.h
 Je rajoute un bit de fin pour savoir quelle est la couleur de celui qui joue

 Une ligne du dataset DataGmes.csv :
 [[0,0,1,0,0,0,0,1], ...., [1,0,0,0,0,0,0,0]] + c1 l1 c2 l2 couleur (celui qui joue)
  |_______8_______|
|_____________________8*64__________________|

à faire : 
    - Pourquoi y a des -1 -> règle du en passant
    - Ajouter le coup en passant et véridier le rook, pas sur de l'avoir bien implémenter

Matrice d'entrée du CNN : un transforme un ligne du dataset en matrice 2D 64x8
                                            _
[[0,0,1,0,0,0,0,1], ...., [1,0,0,0,0,0,0,0]] |
 |_______8_______|                           |
|_____________________8*8__________________| |
                                             8
                                             |
                                             |
                                            _|
                                            
Idée pour le Split : 
Refaire un Split(X,y) pour chaque modèle : y_c1, y_l1, y_c2, y_l2